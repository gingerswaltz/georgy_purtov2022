// Метод простых итераций
#include <iostream>
#include <iomanip>	// для setw()
#include <string>	// для stoi() (перевод строки в число
#include <fstream>  // для файла
#include <vector>   // для векторов
#include <cmath>
using namespace std;

void print(double(&matrix)[5][6]) {// Âûâîä ìàòðèöû
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 6; j++) {
			if ((j + 1) % 6 == 0) // ïî 6 â ñòðîêó çàêèíåì (íå ìåíüøå è íå áîëüøå èíà÷å êðèâî)
				cout << setw(12) << fixed << setprecision(4) <<"== " << matrix[i][j] << endl; // ÷åðåç precision îïðåäåëèì çíàêè ïîñëå çàïÿòîé â ðàçìåðå 4..
			else
				cout << setw(12)  << fixed << setprecision(4) << matrix[i][j] ; // .. à ÷åðåç setw äëèíó ñòðîêè
		}
	}

}

int main()
{
	system("chcp 1251");
	system("cls");


	double matrix[5][6]{ {36, -6, 3, 5, 9, 47},
        {-8, 24, -8, 4, -2, 20},
        {-5, -5, 34, 6, 7, 111},
        {2, -4, 2, 	19, 3, 44},
        {-6, 4, -1, 6, 26, 29} };

	cout << "Default system: "<< "\n\n" ;
	print(matrix);
	/*Проверить условие, что элемент akk, находящийся на k-й
позиции главной диагонали матрицы не является нулём.
В случае, когда элементы матрицы являются вещественными 
числами, это условие приобретает вид ∣akk∣ < ", где " –
положительное число, близкое к нулю. Если диагональный
элемент равен нулю или очень мал, то в столбце ниже его
необходимо найти ненулевой элемент (он найдётся в любом
случае, иначе система вырождена, что противоречит нашему
предположению) и переставить строку, в которой нашёлся
ненулевой элемент и строку с номером k.
*/
	
	for (int k = 0; k < 5; k++) {//  код для проверки 0 на главной диагонали и перестановки не нулевых значений
		if (matrix[k][k] == 0)
		{
			int rows = k + 1; // номер строки увеличивается на 1 если элемент нулевой
			while (matrix[k][k] == 0) { // пока элемент нулевой, проверяем
				if ((matrix[rows][k] != 0) or (rows > 5)) { // если очередной элемент вдруг ненулевой или нумерация строк превзошла 5 
					matrix [k][j]+=
					cout << endl; // ставим пробел чтобы читалось нормально
					print(matrix); // печатаем проходную матрицу
				}
				rows++;
			}
		}
/* Преобразовать все числа, не находящиеся в k-й строке или k-м
			столбце по формуле (правило прямоугольника)*/
		for (int i = 0; i < 5; i++)
		{
			for (int j = k + 1; j < 6; j++)
			{
				if (i != k and j > k) 
				{
					matrix[i][j] = (matrix[i][j] * matrix[k][k] - matrix[i][k] * matrix[k][j]) / matrix[k][k];

				}
			}
		}
		// Все числа k-го столбца, кроме akk обнулить.
		for (int i = k + 1; i < 5; i++) {
			matrix[i][k] = 0;
		}
		// Все числа k - й строки, кроме akk, разделить на akk.
		for (int j = k + 1; j < 6;j++) { 
			matrix[k][j] = matrix[k][j] / matrix[k][k];
		}
		matrix[k][k] = matrix[k][k] / matrix[k][k];
		cout << endl<<" Output #"<<k+1<<": "<< endl;
		print(matrix);

	}
	
	
	return 0;
}
    
  