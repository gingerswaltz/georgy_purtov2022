<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>График</title>
  <style>
    canvas {
      border: 1px solid #000;
      margin-top: 20px;
      /* Добавляем отступ сверху для второго холста */
    }
  </style>
</head>

<body>
  <canvas id="chartCanvas" width="600" height="400"></canvas>
  <canvas id="bChartCanvas" width="600" height="400"></canvas>
  <canvas id="photoCanvas" width="1920" height="1080"></canvas>

  <!-- Второй холст для копии фото -->
  <input type="file" id="imageInput" accept="image/*" />
  <script>
    var chartCanvas = document.getElementById("chartCanvas");
    var chartCtx = chartCanvas.getContext("2d");
    var photoCanvas = document.getElementById("photoCanvas");
    var photoCtx = photoCanvas.getContext("2d");
    var bChartCanvas = document.getElementById("bChartCanvas");
    var bChartCtx = bChartCanvas.getContext("2d");
    var data = [];
    var barWidth;
    var curvePoints = [];

    function drawChart(data) {
      chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
      var maxValue = Math.max.apply(null, data);
      for (var i = 0; i <= 10; i++) {
        var y =
          chartCanvas.height - 50 - (i / 10) * (chartCanvas.height - 100);
        chartCtx.beginPath();
        chartCtx.moveTo(45, y);
        chartCtx.lineTo(50, y);
        chartCtx.stroke();
        chartCtx.fillText(((maxValue * i) / 10).toFixed(0), 20, y);
      }
      barWidth = (chartCanvas.width - 100) / data.length;
      for (var i = 0; i < data.length; i++) {
        var barHeight = (data[i] / maxValue) * (chartCanvas.height - 100);
        var x = 50 + i * (barWidth + 2);
        var y = chartCanvas.height - 50 - barHeight;
        chartCtx.fillStyle = "#0095DD";
        chartCtx.fillRect(x, y, barWidth, barHeight);
      }
    }
    // Функция для логгирования событий
    function logMouseEvent(eventType, event) {
      //console.log("Событие:", eventType, "Координаты:", event.clientX, event.clientY);
    }
    // Функция обновления данных графика и применения изменений к фотографии
    function updateChartData(newData, event) {
      data = newData;
      console.log("Данные графика обновлены:", newData);
      drawChart(newData);
      drawBlueChart(newData); // Рисуем график синего цвета
    }

    var isDrawing = false;

    function drawBlueChart(data) {
      bChartCtx.clearRect(0, 0, bChartCanvas.width, bChartCanvas.height);
      var maxValue = Math.max.apply(null, data);
      for (var i = 0; i <= 10; i++) {
        var y =
          bChartCanvas.height - 50 - (i / 10) * (bChartCanvas.height - 100);
        bChartCtx.beginPath();
        bChartCtx.moveTo(45, y);
        bChartCtx.lineTo(50, y);
        bChartCtx.stroke();
        bChartCtx.fillText(((maxValue * i) / 10).toFixed(0), 20, y);
      }
      barWidth = (bChartCanvas.width - 100) / data.length;
      for (var i = 0; i < data.length; i++) {
        var barHeight = (data[i] / maxValue) * (bChartCanvas.height - 100);
        var x = 50 + i * (barWidth + 2);
        var y = bChartCanvas.height - 50 - barHeight;
        bChartCtx.fillStyle = "blue"; // Устанавливаем цвет синего графика
        bChartCtx.fillRect(x, y, barWidth, barHeight);
      }
    }

    // Обработчик события mousedown
    chartCanvas.addEventListener("mousedown", function (event) {
      isDrawing = true;
      curvePoints.push({
        x: event.clientX - chartCanvas.offsetLeft,
        y: event.clientY - chartCanvas.offsetTop,
      });
      logMouseEvent("mousedown", event);
    });


     // Обработчик события mouseup
     chartCanvas.addEventListener("mouseup", function (event) {
      if (isDrawing) {
        // Проверяем, начиналась ли отрисовка линии
        isDrawing = false;
        var newData = getUpdatedData(curvePoints);
        updateChartData(newData);
        curvePoints = [];
        applyHistogramToPhoto(newData); // Применяем изменения к фотографии с использованием новых данных
        logMouseEvent("mouseup", event);
      }
    });
    // Обработчик события mousemove
    chartCanvas.addEventListener("mousemove", function (event) {
      if (isDrawing == true) {
        curvePoints.push({
          x: event.clientX - chartCanvas.offsetLeft,
          y: event.clientY - chartCanvas.offsetTop,
        });
        drawSegment(
          curvePoints[curvePoints.length - 2],
          curvePoints[curvePoints.length - 1]
        );
      }
      logMouseEvent("mousemove", event);
    });
// блю
     // Обработчик события mousedown
     bChartCanvas.addEventListener("mousedown", function (event) {
      isDrawing = true;
      curvePoints.push({
        x: event.clientX - bChartCanvas.offsetLeft,
        y: event.clientY - bChartCanvas.offsetTop,
      });
      logMouseEvent("mousedown", event);
    });


     // Обработчик события mouseup
     bChartCanvas.addEventListener("mouseup", function (event) {
      if (isDrawing) {
        // Проверяем, начиналась ли отрисовка линии
        isDrawing = false;
        var newData = getUpdatedData(curvePoints);
        updateChartData(newData);
        curvePoints = [];
        applyHistogramToPhoto(newData); // Применяем изменения к фотографии с использованием новых данных
        logMouseEvent("mouseup", event);
      }
    });
    // Обработчик события mousemove
    bChartCanvas.addEventListener("mousemove", function (event) {
      if (isDrawing == true) {
        curvePoints.push({
          x: event.clientX - bChartCanvas.offsetLeft,
          y: event.clientY - bChartCanvas.offsetTop,
        });
        drawSegment(
          curvePoints[curvePoints.length - 2],
          curvePoints[curvePoints.length - 1]
        );
      }
      logMouseEvent("mousemove", event);
    });

    function drawSegment(startPoint, endPoint) {
      if (curvePoints.length >= 2) { // Проверяем, что есть хотя бы две точки
        chartCtx.strokeStyle = "#0095DD"; // Устанавливаем цвет только здесь
        chartCtx.beginPath();
        chartCtx.moveTo(startPoint.x, startPoint.y);
        chartCtx.lineTo(endPoint.x, endPoint.y);
        chartCtx.stroke();
      }
    }

   

    function drawCurve(points) {
      chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
      drawChart(data);
      chartCtx.beginPath();
      chartCtx.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < points.length; i++) {
        chartCtx.lineTo(points[i].x, points[i].y);
      }
      chartCtx.stroke();
    }

    function getUpdatedData(points) {

      var newData = data.slice();
      var maxValue = Math.max.apply(null, data);

      for (var i = 0; i < points.length; i++) {
        var columnIndex = Math.floor((points[i].x - 50) / (barWidth + 2));
        var changeValue = Math.round(
          (chartCanvas.height - 50 - points[i].y) /
          ((chartCanvas.height - 100) / maxValue)
        );
        if (changeValue < 0) changeValue = 0;
        if (changeValue > maxValue) changeValue = maxValue;

        newData[columnIndex] = changeValue;
      }


      return newData;
    }



    document
      .getElementById("imageInput")
      .addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (file) { // Проверяем, что файл выбран
          const reader = new FileReader();
          reader.onload = function (e) {
            const image = new Image();
            image.src = e.target.result;
            image.onload = function () {
              var canvas = document.createElement("canvas");
              var ctx = canvas.getContext("2d");
              canvas.width = image.width;
              canvas.height = image.height;
              ctx.drawImage(image, 0, 0);
              var pixelData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              ).data;
              var histogramData = calculateHistogram(pixelData);
              console.log("Гистограмма цветов:", histogramData);
              updateChartData(histogramData, "change event"); // Добавляем логгирование события
              photoCtx.drawImage(image, 0, 0); // Отображаем копию фото на втором холсте
            };
          };
          reader.readAsDataURL(file);
        }
      });


    function calculateHistogram(pixelData) {
      const histogram = new Array(256).fill(0);
      for (let i = 0; i < pixelData.length; i += 4) {
        const red = pixelData[i];
        histogram[red]++;
      }
      return histogram;
    }

    // Переменная для хранения предыдущих данных гистограммы
    var previousHistogramData = null;

    // Применяем новую гистограмму к фотографии
    function applyHistogramToPhoto(histogramData) {
      //console.log('Данные гистограммы перед применением:', histogramData); // Логгирование данных до применения

      // Проверяем, есть ли предыдущие данные
      if (previousHistogramData !== null) {
        // Сравниваем предыдущие данные с текущими
        var equal = true;
        for (var i = 0; i < histogramData.length; i++) {
          if (previousHistogramData[i] !== histogramData[i]) {
            equal = false;
            break;
          }
        }
        if (equal) {
          //console.error('Предыдущие данные гистограммы равны текущим данным');
        }
      }

      // Сохраняем текущие данные в качестве предыдущих
      previousHistogramData = histogramData.slice(); // Создаем копию массива

      var imageData = photoCtx.getImageData(
        0,
        0,
        photoCanvas.width,
        photoCanvas.height
      );
      var pixels = imageData.data;
      var numPixels = pixels.length / 4;
      var cumulativeHistogram = calculateCumulativeHistogram(histogramData);

      // Применяем гистограммное выравнивание только к красному каналу
      for (var i = 0; i < pixels.length; i += 4) {
        var red = pixels[i];
        var green = pixels[i + 1];
        var blue = pixels[i + 2];

        // Применяем гистограммное выравнивание только к красному каналу
        pixels[i] = (cumulativeHistogram[red] / numPixels) * 255;
        pixels[i + 2] = (cumulativeHistogram[blue] / numPixels) * 255;
      }

      photoCtx.putImageData(imageData, 0, 0);

      // Получаем данные гистограммы после применения
      var updatedHistogramData = calculateHistogram(photoCtx.getImageData(0, 0, photoCanvas.width, photoCanvas.height).data);
      console.log('Данные гистограммы после применения:', updatedHistogramData);
    }


    function calculateCumulativeHistogram(histogram) {
      var cumulativeHistogram = [];
      var sum = 0;
      for (var i = 0; i < histogram.length; i++) {
        sum += histogram[i];
        cumulativeHistogram.push(sum);
      }
      return cumulativeHistogram;
    }


  </script>
</body>

</html>