///@author: georgy purtov
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;		// пространство имён 

int main()
{
	
	int rows = 4, cols = 8; // строки, столбцы
	int k = 0;				// шаги цикла, это номер преобразуемого столбца(номер диагонального элемента главной диагонали основной
//матрицы)
	int m = 0;
	float e = 0.0000001;	// чиселко которое нам не надо (меньше 0 грубо говоря)

/*нужно приписать справа от матрицы A
единичную матрицу, получив расширенную матрицу*/
	float arr[4][8] = 
{{ -1, -1, 2, 2, 1, 0, 0, 0},
{ 1, 0, -1, -1, 0, 1, 0, 0},
{ -1, -3, 3, 1, 0, 0, 1, 0},
{ 2, 4, -4, -3, 0, 0, 0, 1} };

/*метод Жордана-Гаусса, только с отличием, что к основной матрице
присоединён не столбец свободных коэффициентов, а целая их
матрица*/

	cout << "Изначальная матрица" << endl;
	// выводим для проверки
	for (int a = 0; a < rows; a++) // Вывод матрицы
	{
		cout << "|";
		for (int r = 0; r < cols; r++)
		{
			cout << setw(12) << arr[a][r] << "|";
		}
		cout << endl;
	}
	cout << endl;

	while (k < rows)
	{
		if (fabs(arr[k][k]) < e)					// если на главной диагонали 0
		{
			for (int i = k; i < rows; i++)			//Смотрим элементы ниже
			{
				if (arr[i][k] != 0 && m == 0)	//среди элементов столбца с номером k, находящихся ниже элемента akk, найти ненулевой элемент;
				{ ///..пусть этот ненулевой элемент находится в строке с номером m, 
					m = 1;
					for (int j = 0; j < cols; j++)	//
					{
						arr[k][j] += arr[i][j];		
			    /*  тогда необходимо
				к элементам строки с номером k прибавить соответствующие
				элементы строки с номером m; */
					}
				}
			}

			for (int a = 0; a < rows; a++) //Вывод матрицы
			{
				cout << "|";
				for (int r = 0; r < cols; r++)
				{
					cout << setw(12) << arr[a][r] << "|";
				}
				cout << endl;
			}
			cout << endl;
		}

		for (int i = 0; i < rows; i++)		//перебор строк
		{
			for (int j = 0; j < cols; j++)	// перебор столбцов
			{
				if (i != k && k < j)		//заполнение по формуле Жордана-Гаусса (правило прямоугольника)
				{
					arr[i][j] = (arr[i][j] * arr[k][k] - arr[i][k] * arr[k][j]) / arr[k][k];
					/* элементы,
находящиеся правее столбца с номером k, но не в строке с
номером k*/
				}
			}
		}

		for (int i = 0; i < rows; i++)	//обнуление элементов k - го столбца
		{
			if (i != k)					
			{
				arr[i][k] = 0;			//обнуление эллементов столбца
			}
		}

		for (int j = cols - 1; j >= k; j--) // Делим k-ю строку на a[k,k], спускаясь вниз
		{
			arr[k][j] = (arr[k][j] / arr[k][k]);
		}

		for (int i = 0; i < rows; i++)		//Вывод матрицы
		{
			cout << "|";
			for (int j = 0; j < cols; j++)
			{
				cout << setw(12) << arr[i][j] << "|";
			}
			cout << endl;
		}
		cout << endl;

		k++;
	}
}